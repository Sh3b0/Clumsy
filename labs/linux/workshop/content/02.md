---
title: Command-line and file manipulation
---

### Part 1: echo, pipes, redirects and quotes

- On your machine login with password. Open terminal. Check your location

  ```execute
  pwd
  ```

- Create a directory

  ```execute
  mkdir mydocs
  ```

- Change directory

  ```execute
  cd mydocs
  ```

- Create file

  ```execute
  touch textproc
  ```

- Check directory

  ```execute
  ls -la
  ```

- Copy the files from the `/home/$USER/mydocs/textproc` directory into your home directory

  ```execute
  cd ..
  cp -R mydocs/textproc ~ 
  ```

- Redirect output to a file

  ```execute
  echo "My name is $USER and my home directory is $HOME" > simple_echo
  cat simple_echo
  ```

- We will now append to the file using the append operator: `>>`

  ```execute
  echo "My Salary is "$"100" >> simple_echo
  cat simple_echo
  ```

- Notice how the following two commands acheive the same result over a text file.

  ```execute
  cp simple_echo new_echo
  ```

  ```execute
  cat simple_echo > new_echo
  ```

- If we `cat` a file that doesn’t exist

  ```execute
  cat nofile
  ```

- We get an error message shown in `stderr` stread. Let’s redirect this error using the error redirection operator `2>`

  ```execute
  cat nofile 2> error_out
  ```

- If you view the `error_out`, it now contains the error messages that would have gone to the screen. We can send errors to the same place as stdout by using `2>&1`

  ```execute
  cat nofile > allout 2>&1
  ```

- We should now have a file that contains the “simple_echo” text and the error message in the file `allout`.

- Type in the following

  ```execute
  cat << foobar
  Hello foobar
  foobar
  ```

- Notice how it only outputs when the line `foobar` is entered on its own line. Let’s add line numbers to the file fragmented using the `nl` command.

- Before you use it, create a file `fragmented.txt` with 5 lines of any text (you can use `nano ` to create the file)

  ```execute
  nl < fragmented.txt
  ```

- Notice how it only puts line numbers on lines with entries. Also re-run the command without the `<`. It should still work. This is because it takes its std input from a file. If no file was specified then it would expect std in from the keyboard. Try it. You will get a flashing cursor. Put some values in followed by return. Notice it numbers each entry. Use Ctrl-c to end it.

- Now let us read std input from the keyboard until a specific marker. We will make the specific marker the word “end”

  ```execute
  sort << end
  ```

- Enter some names followed by return. Then the last entry type 

  ```execute
  end
  ```

- Notice how it finishes the stdin from the keyboard and outputs the sorted information. If you wanted to store this information

  ```execute
  sort << end > sorted
  ```

- If you wanted to line number this output regardless of blank lines

  ```execute
  sort << end | nl -ba > sorted_numbered
  ```

- You can turn on the backslash escaped character like tab, backspace, form feed, newline etc, by specifying `-e`  with echo

  ```execute
  echo -e "Next is the \nNew line"
  ```

- Use combination of pipe `|` and `grep` to filter data in output

  ```execute
  cat /etc/passwd | grep $USER
  ```

- Write a compound command to write input to a file, and then sort the content of the file.

  ```execute
  echo -e "hello\na new day\nsee the world\ncall sign" > newfile.txt && sort newfile.txt
  ```

### Part 2: heads, tails, cat and tac

- Create a file and following data inside

  ```execute
  echo -e "for1\nfor2\nfor3\nfor4\nfor5\nfor6\nfor7\nfor8\nfor9\nfor10" > numbers
  ```

- Read the last five numbers

  ```execute
  tail -n5 numbers
  ```

- Look at the first 3 lines

  ```execute
  head -n3 numbers
  ```

- Reverse the contents of the file using tac

  ```execute
  tac numbers
  ```

### Part 3: cut

- To cut out specific information from a file you can use the cut command. You can specify delimiters and fields within the cut command. Following will pull out field 1, 4 and 5 in the passwd file

  ```execute
  cut -d: -f1,4,5 /etc/passwd
  ```

- To output the mounted filesystems. Space as the field delimiter

  ```execute
  cut -d" " -f1,2 /etc/mtab
  ```

- Extracting fields 1 3 11 and 12 from a uname kernel output.

  ```execute
  uname -a | cut -d" " -f1,3,11,12
  ```

### Part 4: unique lines extraction, sorting and filtering

- Create the following file called unique with the following content

  ```execute
  nano unique.txt
  ```

  Add the following content to the file

  ```execute
  This line occurs only once. 
  This line occurs twice.
  This line occurs twice.
  This line occurs three times.
  This line occurs three times.
  This line occurs three times.
  ```

- Using the `uniq` command we can count and extract unique lines

  ```execute
  uniq -c unique.txt
  uniq -u unique.txt
  ```

- We can sort files using the sort command.

  ```execute
  sort /etc/passwd
  ```

- If you wish to sort with a different delimiter then you must specify a delimiter with the `-t` option

  ```execute
  sort -t: -k1 /etc/passwd
  ```

### Part 5: bash helpers

- The bash history helps you view commands you have run in the past, and you can repeat them if you want. View your bash command history

  ```execute
  history
  ```

  Example output:

  ```execute
    1  uuidgen
    2  pwd
    3  sudo apt update
    4  sudo apt upgrade
    5  cd Downloads/
  ```

  The output contains unique index numbers with their corresponding command.

- Run any command in your history by typing `!N`. Replace `N` with the number that corresponds with the command you want to repeat. For example to repeat the command `pwd` in the output above, run `!2`

- Ping localhost on your machine

  ```execute
  ping 127.0.0.1
  ```

- Terminate the ping process by pressing `Ctrl-C`.

- Run the last command in your bash history

  ```execute
  !!
  ```

### Part 6: Environment Variables

Environment variables are accessible in your shell. They are commonly used to avoid writing explicit values in scripts, or to set secrets like passwords.

- Run  `printenv` to list all environment variables.
- Run `printenv USER`  or `echo $USER` to print the value of `$USER` variable
- Run `export VARIALBE=value` to set an environment variable.
  - The variable will only be accessible in the current shell/script. Run `printenv USER` in another terminal, you will see that the variable is not set there.
- To make the variable available in all bash sessions, you can modify `~/.bashrc` to include the export command.
  - Commands in `.bashrc` are executed every time a new shell is launched.
  - `.bashrc` is user-specific, while `/etc/environment` is accessible to all users.
- To load new changes, run `source ~/.bashrc`
  - `source` command runs a given script in the current shell (without creating a new shell). 
- **PATH** environment variable contains the list of directories containing executables (separated by `:`)
  - Run `printenv PATH`, you should see something similar to `/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin`
  - Scripts for any executable you use (like `echo`, `cat`, ...) should be located in one of the directories to be recognizable.
- Run `export PATH=$PATH:/home/$USER` to include another directory in the PATH.
