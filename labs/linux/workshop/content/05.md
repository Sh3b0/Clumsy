---
title: Manaing Processes
---

### Part 1: Process id and jobs

- We will start a few processes and manage them through the command line. Open a command shell and change directory to your home. Start the top command and put it into the background. Use `&` to put the process in the background

  ```execute
  top &
  ```

- Then start a background process called `yes` and redirect its out to `/dev/null` (the black hole)

  ```execute
  yes > /dev/null &
  ```

- Now let’s start an `md5sum` process to calculate the md5 hash of the first drive on the system. Notice how this hangs the prompt; it should take a long time to complete this task.

  ```execute
  md5sum /dev/sda
  ```

- Let’s stop the process and background it. To stop the process push `CTRL+Z`.

- Now restart the job in the background. To see the jobs numbers use the command `jobs`

- Identify `id` number of the job `md5sum` from the previous command and point it with `bg` command

  ```execute
  bg 3
  ```

- Now list the current jobs running and stopped, see the changes

  ```execute
  jobs
  ```

- We can bring specific job also to the terminal screen.

  ```execute
  yes > /dev/null &fg 3
  ```

- Afterwards you can terminate the process by `CTRL+C`

  > `CTRL+C` – sends to a process by its controlling terminal (by the TTY driver) SIGINT signal to the current foreground job.

- To list the process IDs of the current processes running in the current shell

  ```execute
  ps
  ```

- The fundamental way of controlling processes in Linux is by sending signals to them. There are multiple signals that you can send to a process, to view all the signals run

  ```execute
  kill -l
  ```

- Identify the process ID for the `yes` process, in this example its ID is `27522`. To kill this process with a SIGTERM (-15)

  ```copy-and-edit
  kill 27522
  ```

- If that failed, you can use a SIGKILL (-9)

  ```copy-and-edit
  kill -9 27522
  ```

- To list all process running on the system, issue the following command

  ```execute
  ps -ef
  ```

- To find the process ID of a specific process named `bash`

  ```execute
  ps -ef | grep bash
  ```

- Another useful command is the pstree command which shows a tree structure of the cascading process IDs (-p).

  ```execute
  pstree -p
  ```

- When you press the `CTRL+C` or Break key at your terminal during execution of a shell program, normally that program is immediately terminated, and your command prompt returns. This may not always be desirable. For instance, you may end up leaving a bunch of temporary files that won’t get cleaned up.

- Trapping these signals is quite easy, and the trap command has the following syntax:

  ```copy-and-edit
  trap "commands" signals
  ```

  Here command can be any valid Unix command, or even a user-defined function, and signal can be a list of any number of signals you want to trap.

  There are two common uses for trap in shell scripts:

  - Clean up temporary files
  - Ignore signals

- Let’s create a script with a trap `SIGINT`. Save the script as `sleeper.sh`

  ```bash
  #!/bin/bash
  
  trap "echo SIGINT encountered, Goodbye forever!" SIGINT
  echo Hello, I am now going to sleep
  sleep infinity
  ```

  > The command to execute when the trap is encountered must be in quotes.

- Now run the script

  ```execute
  bash sleeper.sh
  ```

- Send a `SIGINT` by pressing `CTRL+C` on the keyboard.
  ```execute
  <ctrl+c>
  ```

  > Remember, you can also find the process ID and then use `kill` to send the signal in the form `kill -signal pid`

- You can also use trap to ensure the user cannot interrupt the script execution. This feature is important when executing sensitive commands whose interruption may permanently damage the system. The syntax for disabling a signal is:

  ```copy-and-edit
  trap "command" [signal]
  ```

  - Double quotation marks mean that no command will be executed when the signal is received. For example, to trap the SIGINT and SIGABRT signals, type `trap "" SIGINT SIGABRT`

### Part 2: The proc file system

The `/proc/` directory — also called the proc file system — contains a hierarchy of special files which represent the current state of the kernel — allowing applications and users to peer into the kernel’s view of the system.
Within the `/proc/` directory, one can find a wealth of information detailing the system hardware and any processes currently running. In addition, some of the files within the `/proc/` directory tree can be manipulated by users and applications to communicate configuration changes to the kernel.

- You can view the `/proc/` virtual files with the command line file readers. For example, view `/proc/cpuinfo`

  ```execute
  cat /proc/cpuinfo
  ```

  When viewing different virtual files in the `/proc/` file system, some of the information is easily understandable while some is not human-readable. This is in part why utilities exist to pull data from virtual files and display it in a useful way. Examples of these utilities include `lspci`, `apm`, `free`, and `top`.

- Most virtual files within the `/proc/` directory are read-only. However, some can be used to adjust settings in the kernel. This is especially true for files in the `/proc/sys/` subdirectory.

- To change the value of a virtual file, use the `echo` command and redirect (>) the new value to the file. For example, to change the hostname on the fly, type:

  ```execute
  echo newname > /proc/sys/kernel/hostname 
  ```

- Other files act as binary or Boolean switches. Typing `cat /proc/sys/net/ipv4/ip_forward` returns either a 0 or a 1. A `0` indicates that the kernel is not forwarding network packets. Using the echo command to change the value of the `ip_forward` file to `1` immediately turns packet forwarding on.

- On multi-user systems, it is often useful to secure the process directories stored in `/proc/` so that they can be viewed only by the `root` user. You can restrict the access to these directories with the use of the `hidepid` option.

- To change the file system parameters, you can use the `mount` command with the `-o` remount option.

  ```execute
  sudo mount -o remount,hidepid=value /proc
  ```

  Here, value passed to hidepid is one of:

  - `0` (default) — every user can read all world-readable files stored in a process directory.
  - `1` — users can access only their own process directories. This protects the sensitive files like cmdline, sched, or status from access by non-root users. This setting does not affect the actual file permissions.
  - `2` — process files are invisible to non-root users. The existence of a process can be learned by other means, but its effective UID and GID is hidden. Hiding these IDs complicates an intruder’s task of gathering information about running processes.

- To make process files accessible only to the root user, type:

  ```execute
  sudo mount -o remount,hidepid=1 /proc
  ```

  With `hidepid=1`, a non-root user cannot access the contents of process directories. An attempt to do so fails with the following message:

  ```execute
  ls /proc/1/
  ls: /proc/1/: Operation not permitted
  ```

  With hidepid=2 enabled, process directories are made invisible to non-root users:

  ```execute
  ls /proc/1/       
  ls: /proc/1/: No such file or directory
  ```

- Also, you can specify a user group that will have access to process files even when `hidepid` is set to 1 or 2. To do this, use the gid option.

  ```execute
  sudo mount -o remount,hidepid=value,gid=gid /proc
  ```

  > You can find system groups and their respective group IDs in `/etc/group`
  > Replace `gid` with the specific group id. For members of selected group, the process files will act as if `hidepid` was set to `0`. However, users which are not supposed to monitor the tasks in the whole system should not be added to the group.

### Part 3: `top`

- Open a command shell run the `top` command

  > This opens up a tool that shows the top processes running on your system. This tool can be used to kill processes, renice processes, sort and various other process management. Press the h command to get a list of help.
  > Read more at: https://www.guru99.com/managing-processes-in-linux.html

- By default, top sorts the process list using the %CPU column. To sort processes using a different column, press one of the following keys.

  - `M` Sort by the `%MEM` column.
  - `N` Sort by `PID` column.
  - `T` Sort by the `TIME+` column.
  - `P` Sort by the `%CPU` column.

- To show the process command line instead of just the process name, press `c`.

- The filter feature allows using a filter expression to limit which processes to see in the list. Activate the filter option by pressing `o`. The program prompts you to enter a filter expression. You can enter the following to filter processes using more than 1% CPU.

  ```
  %CPU>1.0
  ```

- Clear the filters by pressing `=`

- To filter processes by a specific user, specify the `-u` option when you run the top command

  ```execute
  top -u root
  ```

- The first five lines of the output show some useful statistics
  ```
  top - 20:38:40 up  3:56,  2 users,  load average: 0.48, 0.65, 0.59
  Tasks: 386 total,   1 running, 385 sleeping,   0 stopped,   0 zombie
  %Cpu(s):  1.2 us,  0.5 sy,  0.0 ni, 98.3 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st 
  MiB Mem :  15685.7 total,   8313.0 free,   3343.0 used,   4993.5 buff/cache     
  MiB Swap:      0.0 total,      0.0 free,      0.0 used.  12342.7 avail Mem 
  ```

  - `top` displays uptime information
  - `Tasks` displays process status information
  - `%Cpu(s)` displays various processor values
  - `MiB Mem` displays physical memory utilization
  - `MiB Swap` displays virtual memory utilization

### Part 4: `free`

- `free` is a popular command used by system administrators on Unix/Linux platforms. It’s a powerful tool that gives insight into the memory usage in human-readable format.
- The man page for this command states that free displays the total amount of free and used memory on the system, including physical and swap space, as well as the buffers and caches used by the kernel. The information is gathered by parsing `/proc/meminfo`.

- Run `free -h` for a human-readable output

  ```execute
  free -h
  ```

- `free` provides options to display amount of memory in various units. free `-b`, `-k`, `-m`, `-g` display the amount of memory in bytes, kilobytes, megabytes, gigabytes respectively.

- The various columns, displayed by the various releases above, seek to identify the Total, used, free, shared memory. It also seeks to display the memory held in cache and buffers as well.
