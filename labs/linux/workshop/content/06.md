---
title: Cron Jobs
---

- Let’s create an example script `job.sh`. We can check `log.txt` at any time to see whether our scheduled job has run. Create this script in your home directory

  ```
  #!/bin/bash
  echo `date +"%Y-%M-%d %T"`" - Hello $USER" >> /home/$USER/log.txt
  ```

### Part 1: Adding the job to the user crontab

- To understand the user crontab, let’s add the script to it manually

  ```execute
  crontab -e
  ```

- This command will open an editor to edit the existing user crontab. Let’s append our cron expression:

  ```copy
  30 0 * * * /home/$USER/job.sh
  ```

  This schedules the script to run every day, 30 minutes after midnight.

- We also need to be sure that the current user has execute permissions for this script. So, let’s use the chmod command to add them:

  ```execute
  chmod u+x /home/$USER/job.sh
  ```

  Now, `job.sh` is scheduled and will run every day. We can test this by inspecting the `log.txt` file

### Part 2: Adding the job to the system crontab
To understand the system crontab, let’s also add this script to it manually.

- The system crontab file is kept in `/etc/crontab`. Let’s append the following line:

  ```copy
  30 0 * * * root /home/$USER/job.sh
  ```

  We should note that we need to specify the root username. This is because jobs in system cron are system jobs and will be run by the root user.

### Part 3: Script for adding the job to the user crontab
Now let’s try automating the process to add to the user crontab. Install a new file to crontab.

- Let’s first create a new script file:

  ```execute
  touch /home/$USER/myScript.sh
  ```

- The first thing our script will do is take a copy of all the current jobs. Do not forget to add executable rights for the script to work

  ```copy
  #!/bin/bash
  crontab -l > crontab_new
  ```

  We now have all the previous jobs in the `crontab_new` file. This means we can append our new job to it and then rewrite the crontab by using the edited file as an input argument to the crontab command:

  ```execute
  echo "30 0 * * * /home/$USER/job.sh" >> crontab_new
  crontab crontab_new
  ```
  
- Since the `crontab_new` file is temporary, we can remove it:

  ```execute
  rm crontab_new
  ```

  This method works well, though it does require the use of a temporary file. The main idea here is to add multiple tasks to the existing user jobs. Let’s see if we can optimize it further.

### Part 4: Optimize the previous script by using a pipe
Our previous script relied on a temporary file and had to tidy it up. It also didn’t check whether the cron entry was already installed, and thus, it could install a duplicate entry if executed multiple times.

- We can address both of these by using a pipe-based script. If crontab command has a dash `-`, the crontab data is read from standard the input

  ```copy
  #!/bin/bash
  (crontab -l; echo "30 0 * * * /home/$USER/job.sh") | sort -u | crontab -
  ```

- As before, the `crontab -l` and `echo` commands write out the previous lines of the crontab as well as the new entry. These are piped through the sort command to remove duplicate lines. The `-u` option in `sort`  is for keeping only unique lines. The result of this is piped into the `crontab` command, which rewrites the `crontab` file with the new entries. We should be aware, though, that using sort will completely reorder the file, including any comments. 

- `sort -u` is pretty easy to understand in a script, but we can achieve a less destructive de-duplication with awk:

  ```copy
  #!/bin/bash
  (crontab -l; echo "30 0 * * * /home/$USER/job.sh")|awk '!x[$0]++'|crontab -
  ```

  This will remove all duplicates from the crontab without sorting it.

- The syntax of the awk command used is explained below:
  - `a[$0]` - uses the current line `$0` as key to the array, taking the value stored there. If this particular key was never referenced before, `a[$0]` evaluates to the empty string.
  - The `!` negates the value from before. If it was empty or zero (false), we now have a true result. If it was non-zero (true), we have a false result. If the whole expression evaluated to true, the whole line is printed as the default action print `$0`
  - `++` increment the value of `a[$0]`

### Part 5: Using system crontab

- First, let’s create a new script:

  ```execute
  touch /home/$USER/myScript2.sh
  ```

- The syntax of the system schedule line is similar to the user schedule. We just need to specify the root username in the schedule line

  ```copy
  #!/bin/bash
  sudo /bin/bash -c 'echo "30 0 * * * root /home/$USER/job.sh" >> /etc/crontab'
  ```

- We’re using `sudo /bin/bash` before `echo` because the user needs root access to both echo and redirect as the root user. Otherwise, we’ll get a permission denied error because just echo will run as root and the redirection will be made with the current user’s permission. The `-c` option tells bash to get the command in single quotes as a string and run it in a shell.

- Note that this is plain file manipulation, compared with the `crontab` command used earlier. We can add similar filters like sort or awk if we want to avoid duplicate entries.

### Part 6: Using the /etc/cron.d directory
Besides the `/etc/crontab` path, cron considers all the files in the `/etc/cron.d` directory as system jobs too. So, we can also put the schedule line in a new file in the `/etc/cron.d` directory.

- Let’s now make another script for adding a job to the `cron.d` directory, as an alternative to the `/etc/crontab` file:

  ```execute
  touch /home/$USER/myScript3.sh
  ```

- We need to put the schedule line in a new file in the cron.d directory — we’ll call our file schedule. Note that in `/etc/cron.d`, some filenames are considered invalid. For example, if we choose `schedule.sh` for the filename, it will be skipped because the filename should not have any extension:

  ```copy
  #!/bin/bash
  sudo touch /etc/cron.d/schedule
  ```

- The `cron.d` directory and its sub-directories are usually used by system services, and only the root user can have access to these directories. Also, the files in `/etc/cron.d` must be owned by root. So, we need to use sudo.

- Let’s now add our schedule line to the schedule file and change the permissions.

  ```copy
  sudo /bin/bash -c 'echo "30 0 * * * root /home/$USER/job.sh" > /etc/cron.d/schedule'
  sudo chmod 600 /etc/cron.d/schedule
  ```

- Note that we change the file’s permissions to a minimum `600`. This is because files in `/etc/cron.d` must not be writable by group or other. Otherwise, they will be ignored. Also, the schedule files under `/etc/cron.d` do not need to be executable. So, we don’t need permission `700`.
