---
title: Bash Scripting
---


### Part 1: Bash scripting basics

- Create a shell script `script.sh` and add the following to see the output when you use the various echo options.

  ```copy
  #!/bin/bash
  echo -E "Printing text with newline. This is the dafult option."
  echo -n "What happens when we print text without new line"
  echo -e "\nEscaping \t characters \t to print\nnew lines for example"
  ```

- Execute the script.

  ```execute
  bash script.sh
  ```

- Single line comments begin with `#`

- Append the following lines to `script.sh` and run it again.

  ```copy
  # Adding comments that do nothing
  echo "Testing single line comments"
  ```

- You can use multi line comments. The format is to start with a colon `:` followed by the comments enclosed in single quotes `'`

  ```copy
  : '
  This is a multi line comment
  Nothing happens in this section
  '
  echo "Back to executable commands"
  ```

- Double brackets are used to do arithmetic tasks. For example, append the following to your script.

  ```copy
  # Add two numeric values
  ((sum = 12 + 24))
  
  # Print the sum
  echo $sum
  ```

- Get user input with the `read` command. This is normally used in combination with echo to print a prompt to the user. Append the following to your script.

  ```copy
  echo "What is your favorite fruit?"
  read fruit
  echo "Hey! I like $fruit too."
  ```

### Part 2: Bash loops and conditions

- Create a simple **while** loop. Save the following script as `while_loop.sh`.

  ```copy
  #!/bin/bash
  
  counter=1
  while [ $counter -le 10 ]
  do
    echo $counter
    ((counter++))
  done
  echo All done
  ```

  > `-le` is the same as `<=`.

- Create an **until** loop. The until loop will execute the commands within it until the condition becomes true. Save the following script as `until_loop.sh`.

  ```copy
  #!/bin/bash
  
  counter=1
  until [ $counter -gt 10 ]
  do
    echo $counter
    ((counter++))
  done
  echo All done
  ```

  > `-gt` is the same as `>`.

- Create a simple **for** loop that iterates through the item in a list and prints each of them. Save the following script as `for_loop.sh`.

  ```copy
  #!/bin/bash
  
  names='John Peter Emily'
  for name in $names
  do
    echo $name
  done
  echo All done
  ```

- Bash for loop can be written in “C-Style”. For example save the following script as `uptime.sh`.

  ```copy
  #!/bin/bash
  
  # Loop of ten iterations to print system uptime every 2 seconds.
  for ((i = 1 ; i <= 10 ; i++)); do
    
    echo -e "$i.\t"$(uptime)
    sleep 2
  done
  ```

  Execute the script and analyze the output.

- The **break** statement tells bash to exit the loop. An example is shown in `break.sh` below.

  ```copy
  #!/bin/bash
  
  counter=1
  while [ $counter -le 10 ]
  do
    if [ $counter -eq 5 ]
    then
      echo Script encountered the value $counter
      break
    fi
    echo $counter
    ((counter++))
  done
  echo All done
  ```

  > `-eq` is the same as `=`.

- The **continue** statement skips the cuttent iteration of the loop. Save the following as `continue.sh` and run it.

  ```copy
  #!/bin/bash
  
  counter=0
  while [ $counter -lt 10 ]
  do
    ((counter++))
    if [ $counter -eq 6 ]
    then
      echo Number 6 encountered, skipping to the next iteration
      continue
    fi
    echo $counter
  done
  echo All done
  ```

  > `-lt` is the same as `<`.

### Part 3: If statements

- If statements allow us to make decisions in our script. This is usually utilized with a comparison operator. Save the following as `if_statement.sh`.

  ```copy
  #!/bin/bash
  
  echo -n "Enter the number: "
  read number
  if [ $number -gt 100 ]
  then
    echo That\'s a large number.
  elif [ $number -gt 50 ]
  then
    echo Not so much.
  else
    echo The number is way too small.
  fi
  ```

### Part 4: Bash functions

- Create a simple function

  ```
  fun () { echo "This is a function"; echo; }
  ```

- To view the content of all functions defined in the shell

  ```
  declare -f
  ```

- To list all functions by its name

  ```
  declare -F
  ```

- To view the content of the one your function

  ```
  declare -f fun
  ```

- To remove the function

  ```
  unset fun
  ```

- Now lets create a script with a 2 functions inside it

  ```
  nano funky.sh
  ```

- Inside nano type the following

  ```copy
  #!/bin/bash
  
  JUST_A_SECOND=3
  funky ()
  { # This is about as simple as functions get.
  
      echo "This is a funky function."
      echo "Now exiting funky function."
  } # Function declaration must precede call
  
  fun ()
  { # A somewhat more complex function. 
      i=0
      REPEATS=30
      echo
      echo "And now the fun really begins."
      echo 
      sleep $JUST_A_SECOND 
      while [ $i -lt $REPEATS ] #use as (<,>,=) or (-lt, -gt, -eq)
          do
          echo   "----------FUNCTIONS---------->"
          echo   "<------------ARE-------------"
          echo   "<------------FUN------------>"
          echo
          let "i+=1"
          done
  }
  
  add_fun()
  {
  # A function just to add numbers
  echo $((2+2))
  }
  #Now, call the functions
  funky
  fun
  echo The return value of add_fun is: $(add_fun)
  echo exit $? #check your exit status of the last function/command: if 0-success, otherwise is not
  ```

- Run the script

  ```execute
  bash funky.sh
  ```

- Notice how the functions are only available within the one shell (once you exit it is gone for the parent shell)

  ```execute
  declare -F
  ```

### Part 5: Directory and file manipulation

- You can create a new directory in bash with the `mkdir` command. Save the following script as `mkdir_bash.sh`.

  ```copy
  #!/bin/bash
  echo "Enter directory name"
  read newdir
  `mkdir $newdir`
  ```

- You can check for the existence of a directory before proceeding to create it. Update `mkdir_bash.sh` to look like the script shown below.

  ```copy
  #!/bin/bash
  echo "Enter directory name"
  read newdir
  if [ -d "$newdir" ]
  then
    echo "Directory exist"
  else
    `mkdir $newdir`
    echo "Directory created"
  fi
  ```

- Create a bash script to read every line of a specified file. The file name is passed as a command line argument. Save the following script as `file_reader.sh`.

  ```copy
  #!/bin/bash
  
  file=$1
  
  if [[ "$file" == "" || (! -f "$file") ]]
  then
    echo Using standard input!
    file="/dev/stdin"
  fi
  
  while read -r line
  do
    echo "$line"
  done < "${file}"
  ```

  > - The script reads the first value passed as a command line argument, represented by $1. If a text file is passed, the script will read and output each line of text.
  > - If no command line argument is passed or if the file does not exist, standard input (/dev/stdin) is used instead. This will prompt you to enter text and will output to the terminal screen what is received as input. To signal the end of your stdin input type CTRL+D

- Use this script to read `/etc/passwd`.

  ```execute
  bash file_reader.sh /etc/passwd
  ```

- The Internal Field Separator (IFS) is used to recognize word boundaries. The default value for IFS consists of whitespace characters. Whitespace characters are space, tab and newline. Add the following script to the file `ifs_test.sh`.

  ```copy
  #!/bin/bash
  
  mystring="foo:bar baz rab"
  for word in $mystring; do
    echo "Word: $word"
  done
  ```

- Run the script.

- The default value for the IFS can be changed. Modify `ifs_test.sh` to contain the following.

  ```copy
  #!/bin/bash
  
  IFS=:
  mystring="foo:bar baz rab"
  for word in $mystring; do
    echo "Word: $word"
  done
  ```

- Let’s do this on a larger scale. Read /etc/passwd word by word while using `:` as the IFS. Save the following as `ifs_word.sh`.

  ```copy
  #!/bin/bash
  
  if [[ $# -le 0 ]]
  then
    echo "You did not pass any files as arguments to the script."
    echo "Usage:" "$0" "my-file"
    exit
  fi
  
  IFS=:
  file=$1
  
  if [ ! -f "$file" ]
  then
    echo "File does not exist!"
  fi
  
  for word in $(cat "${file}")
  do
    echo "$word"
  done
  ```

  Run the script specifying `/etc/passwd` as an argument.

  ```
  bash ifs_test.sh /etc/passwd
  ```

### Part 6: Jump directories

Sometimes it is difficult to navigate directories with the possibly infinite number of parent directories we need to provide. For example `cd ../../../../../`. Let’s create a script that will help us jump to a specified directory without executing `cd ../`.

- Create the script `jump_dir.sh`

  ```
  # !/bin/bash
  
  # A simple bash script to move up to desired directory level directly
  
  function jump()
  {
    # original value of Internal Field Separator
    OLDIFS=$IFS
  
    # setting field separator to "/"
    IFS=/
  
    # converting working path into array of directories in path
    # eg. /my/path/is/like/this
    # into [, my, path, is, like, this]
    path_arr=($PWD)
  
    # setting IFS to original value
    IFS=$OLDIFS
  
    local pos=-1
  
    # ${path_arr[@]} gives all the values in path_arr
    for dir in "${path_arr[@]}"
    do
      # find the number of directories to move up to
      # reach at target directory
      pos=$[$pos+1]
      if [ "$1" = "$dir" ];then
  
    	# length of the path_arr
    	dir_in_path=${#path_arr[@]}
  
    	#current working directory
    	cwd=$PWD
    	limit=$[$dir_in_path-$pos-1]
    	for ((i=0; i<limit; i++))
    	do
    	  cwd=$cwd/..
    	done
    	cd $cwd
        break
      fi
    done
  }
  ```

- Make the script executable

  ```
  chmod +x jump_dir.sh
  ```

- Add it to the .bashrc file to make it available on every terminal session.

  ```
  echo "source ~/jump_dir.sh">> ~/.bashrc
  ```

- Open a new terminal and try jumping.

  ```
  jump directory_name
  ```

### Part 7: File and directory test operators

There are several options in bash to check the type of file you are interacting with. In many cases, the options are also used to check for the existence of a specified file or directory. The example below shows the options that can be used.

- Create a script `file_checker.sh` and add the following code:

  ```copy
  #!/bin/bash
  
  if [[ $# -le 0 ]]
  then
    echo "You did not pass any files as arguments to the script."
    echo "Usage:" "$0" "my-file-1 my-file-2"
    exit
  fi
  
  for arg in "$@"
  do
    # Does it actually exist?
    if [[ ! -e "$arg" ]]
    then
        echo "* Skipping ${arg}"
        continue
    fi
  
    # Is it a regular file?
    if [ -f "$arg" ]
    then
        echo "* $arg is a regular file!"
    else
        echo "* $arg is not a regular file!"
    fi
  
    [ -b "$arg" ] && echo "* $arg is a block device."
    [ -d "$arg" ] && echo "* $arg is a directory."
    [ ! -d "$arg" ] && echo "* $arg is not a directory."
  
    [ -x "$arg" ] && echo "* $arg is executable."
    [ ! -x "$arg" ] && echo "* $arg is not executable."
  
    [[ -h "$arg" ]] && echo "* $arg is a symbolic link."
    [ ! -h "$arg" ] && echo "* $arg is not a symbolic link."
  
    [[ -s "$arg" ]] && echo "* $arg has nonzero size."
    [ ! -s "$arg" ] && echo "* $arg has zero size."
  
    [[ -r "$arg" && -d "$arg" ]] && echo "* $arg is a readable directory."
    [[ -r "$arg" && -f "$arg" ]] && echo "* $arg is a readable regular file."
  done
  ```

- Run the script and specify the files you want to check as arguments.

  ```
  bash file_checker.sh /bin/i386 /etc/passwd
  ```

  You should get output similar to the following:

  ```
  * /bin/i386 is a regular file!
  * /bin/i386 is not a directory.
  * /bin/i386 is executable.
  * /bin/i386 is a symbolic link.
  * /bin/i386 has nonzero size.
  * /bin/i386 is a readable regular file.
  * /etc/passwd is a regular file!
  * /etc/passwd is not a directory.
  * /etc/passwd is not executable.
  * /etc/passwd is not a symbolic link.
  * /etc/passwd has nonzero size.
  * /etc/passwd is a readable regular file.
  ```

### Part 8: Hash tables in bash

A dictionary, or a hashmap, or an associative array is a data structure used to store a collection of things. A dictionary consists of a collection of key-value pairs. Each key is mapped to its associated value.

- To declare a dictionary variable in bash, use the `declare` statement with the `-A` option which means associative array. For example:

  ```execute
  declare -A newDictionary
  ```

- We have declared a variable called `newDictionary`. The following syntax can be used to add key-value pairs to the dictionary:

  ```execute
  newDictionary[key]=value
  ```

- Let’s add a key-value pair to the dictionary using the syntax above:

  ```execute
  newDictionary[1]=val1
  newDictionary[2]=val2
  ```

- To retrive the value of a dictionary key, we can use

  ```execute
  echo ${newDictionary[1]}
  ```

- To update the value of a key, we simply overwrite the existing value by writing to the key again. For example, to update `newDictionary[1]`, we do the following:

  ```execute
  newDictionary[1]=val1_upd
  ```

  Retrieve the value of the key `[1]` to verify the update.

  ```execute
  echo ${newDictionary[1]}
  ```

- Use the `unset` command to remove a key-value pair from the dictionary.

  ```execute
  unset newDictionary[1]
  ```

- Verify that the pair has been removed from the dictionary.

  ```execute
  echo ${newDictionary[1]}
  ```

- You can iterate through the dictionary by creating a `for` loop. An example is shown in the script below:

  ```copy
  #!/bin/bash
  declare -A newDictionary
  newDictionary[1]=val1
  newDictionary[2]=val2
  newDictionary[3]=val3
  for key in "${!newDictionary[@]}"; do 
    echo "$key ${newDictionary[$key]}" 
  done
  ```

  You should get an output similar to the following when you run the script:

  ```
  3 val3
  2 val2
  1 val1
  ```

- You can also declare and instantiate a dictionary in one line.

  ```
  declare -A values=([1]=val1 [2]=val2 [3]=val3)
  ```

- Check the content of the dictionary.

  ```
  echo ${values[3]}
  ```

### Part 9: Creating bash menu

The menu allows the user to interact with your bash scripts. The menu typically provides the users options to select, and acts based on the user’s selection. The `select` statement can be used to create a basic bash menu. The `select` statement in combination with `case` statement can be used to create more sophisticated menu options.

#### 9.1. Create a basic menu

- The `select` statement is used to create a menu in the format shown below:

  ```
  select WORD in [LIST];
  do COMMANDS;
  done
  ```

- Create a basic menu `basic_menu.sh` that will prompt the user for their favorite color. Print out the value of any valid menu selection, and then break out of the select statement:

  ```copy
  #!/bin/bash
  
  echo "Enter the number corresponding to your favorite color:"
  
  select COLOR in red orange yellow green blue indigo violet
  do
     echo "Your favorite color is: $COLOR"
     break
  done
  ```

- Run the script and you should get results similar to the following:

  ```
  Enter the number corresponding to your favorite color:
  1) red
  2) orange
  3) yellow
  4) green
  5) blue
  6) indigo
  7) violet
  #? 5
  Your favorite color is: blue
  ```

#### 9.2. Create a menu using the case statement

- Utilizing the `case` statement provides more flexibility than when using the `select` statement alone. By adding a `case` for each selection, the script can execute separate tasks based on what the user selects. The reserved Bash variable `PS3` is used with `select` statements to provide a custom prompt to the user. The select statement when combined with `case` statement is used to create menu in the format shown below:

  ```
  select WORD in [LIST];
  do
    case $WORD in
      element-1-in-LIST)
        COMMAND1
        ;;
      element-2-in-LIST)
        COMMAND2
        ;;
    esac
  done
  ```

- Create a bash script `lazy_tool.sh` to help you check hostname, private IP address, and public IP address exit node based on selected options.

  ```copy
  #!/bin/bash
  
  echo "This script helps the lazy to check hostname, private IP addresses, and public IP address"
  echo "Enter a number corresponding to what you want to check"
  PS3="My selection is: "
  
  select UTILITY in hostname system-IP-address public-IP-address exit;
  do
     case $UTILITY in
        hostname)
            echo "Your hostname is: "$(hostname)
            ;;
        system-IP-address)
            echo "Your system IP addresses are: "$(ip -4 addr | grep -oP '(?<=inet\s)((25[0-5]|(2[0-4]|1\d|[1-9]|)\d)\.?\b){4}')
            # We can also use the following regex to extract the IP address: (?<=inet\s)\d+(\.\d+){3}
            ;;
        public-IP-address)
            echo "Your public IP address is: "$(wget -qO - icanhazip.com)
            ;;
        exit)
            echo "You are now exiting this script."
                break
                ;;
        *)
            echo "Please make a selection from the provided options."
    esac
  done
  ```

  > Notice how one of the options in the script uses the `grep` utility to extract IP addresses from the output of the `ip -4 addr` command.

- Run the script and you should get results similar to the following:

  ```
  This script helps the lazy to check hostname, private IP addresses, and public IP address
  Enter a number corresponding to what you want to check
  1) hostname
  2) system-IP-address
  3) public-IP-address
  4) exit
  My selection is: 1
  Your hostname is: ADAGBA
  My selection is: 2
  Your system IP addresses are: 127.0.0.1 192.168.132.134
  My selection is: 4
  You are now exiting this script.
  ```

#### 9.3. Create a menu that includes a submenu

The concept of a basic menu and menu with the `case` statement are combined to create a menu that includes a submenu.

- Create a bash script `submenu.sh` that provides a menu with submenu. The script will read all files in the current working directory and display them to the user as selectable options. Once the user selects a file, a submenu will appear prompting the user to select an action to perform on the previously selected file. The submenu allows a user to delete a file, to display the file’s contents, or to simply exit the script.

  ```copy
  #!/bin/bash
  
  echo "Use this script to manipulate files in your current working directory:"
  echo "----------------------------------------------------------------------"
  echo "Here is a list of all your files. Select a file to access all"
  echo "available file actions:"
  
  select FILE in * exit;
  do
    case $FILE in
    exit)
        echo "Exiting script ..."
        break
        ;;
    *)
        select ACTION in delete view exit;
        do
            case $ACTION in
            delete)
                echo "You've chose to delete your file" "$FILE"
                rm -i "$FILE"
                echo "File ""$FILE" "has been deleted"
                echo "Exiting script ..."
                break
                ;;
            view)
                echo "Your selected file's contents will be printed to the terminal:"
                cat "$FILE"
                echo "------------------------"
                echo "Exiting script ..."
                break
                ;;
            exit)
                echo "Exiting script ..."
                break
                ;;
            esac
        done
        break
        ;;
    esac
  done
  ```

- Run the script and you should get results similar to the following:

  ```
  Use this script to manipulate files in your current working directory:
  ----------------------------------------------------------------------
  Here is a list of all your files. Select a file to access all
  available file actions:
  1) allout                                          8) lazy_tool.sh
  2) aws                                             9) log
  3) awscliv2.zip                                   10) regextest.txt
  4) basic_menu.sh                                  11) server-data.log
  5) cluster-role-trust-policy.json                 12) submenu.sh
  6) google-cloud-sdk                               13) uptime.sh
  7) google-cloud-sdk-377.0.0-linux-x86_64.tar.gz   14) exit
  #? 10
  1) delete
  2) view
  3) exit
  #? 2
  Your selected file's contents will be printed to the terminal:
  03/22 08:51:06 INFO   :...read_physical_netif: index #0, interface VLINK1 has address 129.1.1.1, ifidx 0
  03/22 08:51:06 ERROR   :...read_physical_netif: index #4, interface CTCD0 has address 9.67.116.98, ifidx 4
  ------------------------
  Exiting script ...
  ```


### Part 10: Command exit code

You can verify whether a bash command executed successfully by viewing the exit status code of the command. The exit status of the previously executed command is stored in the `$?` variable. A successful command returns a `0`, while an unsuccessful one returns a non-zero value that usually can be interpreted as an error code.

- Run the command `ls -lah`.
- View the exit status of the previous command with `echo "$?"`.
- Now run a command that will fail. For example: `ls -lah /directorythatdoesnotexist`
- Run `echo "$?"` again to view the exit status. You should get a value that is not `0`.

### Part 11: Using `set -xe` to debug bash scripts

When there is an error that stops the execution of a bash script, the bash interpreter usually displays the line number that triggered the error. However, in some cases, it might be necessary to trace the flow of execution of the script. This provides more insight into the conditions that are met, and the state of the loops.

- The `set` command is used to set or unset shell options or positional parameters.

- We can use the `set -e` option to exit the bash script if any command or statement generates a non-zero exit code. This is defined at the start of the script and it applies globally to all commands in the script.

- Additionally, we can also use the `set -x` option to display commands and arguments before they are executed. With this option, we can see every line of command that is executing in the script.

- The `set -e` option and `-x` options can be combined to become useful debugging tools. The option `-e` exits the script as soon as an error is encountered, and the option `-x` shows the command that was running when the error was encountered.

- Create a bash script `loop_debug.sh` and add the following to it:

  ```copy
  #!/bin/bash
  
  set -xe
  
  # This script prints  all user profiles.
  
  FILE=".bashrc"  #  File containing user profile,
              #+ was ".profile" in original script.
  
  for home in `awk -F: '{print $6}' /etc/passwd`
  do
    [ -d "$home" ] || continue    # If no home directory, go to next.
    [ -r "$home" ] || continue    # If not readable, go to next.
    (cd $home; [ -e $FILE ] && less $FILE)
  done
  
  exit 0
  ```

- Run the script and analyze the output. Did the script stop prematurely?

- Remove the option `-e` and run the script again. Did you notice any difference? Why is it different?

- Now completely remove `set -xe` to see how the program executes without these options.
